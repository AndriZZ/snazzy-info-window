{"version":3,"sources":["snazzy-info-window.js"],"names":["copyKeys","target","source","Object","keys","forEach","key","mergeDefaultOptions","opts","copy","_defaultOptions","obj","_typeof","objCopy","parseAttribute","attribute","defaultValue","re","test","match","exec","number","units","value","original","setHTML","container","content","firstChild","removeChild","innerHTML","appendChild","oppositePosition","p","capitalizePosition","charAt","toUpperCase","slice","_classPrefix","_root2","_inverseRoot2","_defaultShadow","h","v","blur","spread","color","position","pointer","openOnMarkerClick","closeOnMapClick","showCloseButton","panOnOpen","edgeOffset","top","right","bottom","left","SnazzyInfoWindow","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_html","_opts","_callbacks","callbacks","_marker","marker","_isOpen","_listeners","google","_openOnMarkerClickListener","maps","event","addListener","getMap","open","toLowerCase","undefined","border","shadow","callback","lamda","apply","listener","removeListener","result","activateCallback","setMap","clearListeners","_this2","offset","wrapper","style","marginLeft","marginTop","bg","backgroundColor","contentWrapper","pointerBg","padding","shadowFrame","borderRadius","fontSize","fontColor","shadowPointer","width","height","pointerBorder","borderWidth","bWidth","Math","round","offsetWidth","clientWidth","pLength","min","offsetHeight","triangleDiff","reverseP","borderColor","isSet","hOffset","vOffset","formatBoxShadow","boxShadow","hRotated","vRotated","shadowPointerInner","opacity","shadowWrapper","markerPos","getProjection","fromLatLngToDivPixel","floatWrapper","floor","y","x","resize","reposition","_this3","applyCss","element","args","i","length","className","newElement","_len","arguments","Array","_key","document","createElement","wrapperClass","closeButtonMarkup","d","closeButton","setAttribute","getPanes","floatPane","map","push","close","_previousWidth","_previousHeight","getDiv","ow","oh","pw","ph","draw","addDomListener","e","cancelBubble","stopPropagation","mouseEvents","parent","parentElement","mb","getBoundingClientRect","mib","getMapInnerBounds","wb","dx","dy","panBy","maxWidth","maxHeight","OverlayView"],"mappings":"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","file":"snazzy-info-window.min.js","sourcesContent":["// Global variables\nconst _classPrefix = 'si-';\nconst _root2 = 1.41421356237;\nconst _inverseRoot2 = 0.7071067811865474;\nconst _defaultShadow = {\n    h: '0px',\n    v: '3px',\n    blur: '6px',\n    spread: '0px',\n    color: '#000'\n};\nconst _defaultOptions = {\n    position: 'top',\n    pointer: true,\n    openOnMarkerClick: true,\n    closeOnMapClick: true,\n    showCloseButton: true,\n    panOnOpen: true,\n    edgeOffset: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 20\n    }\n};\n\n// Copy keys from the source into the target\nfunction copyKeys(target, source) {\n    if (target && source) {\n        Object.keys(source).forEach((key) => {\n            target[key] = source[key];\n        });\n    }\n}\n\n// We need to safely merge options from the defaults. This will make\n// sure settings like edgeOffset are properly assigned.\nfunction mergeDefaultOptions(opts) {\n    const copy = {};\n    copyKeys(copy, _defaultOptions);\n    copyKeys(copy, opts);\n    Object.keys(_defaultOptions).forEach((key) => {\n        const obj = _defaultOptions[key];\n        if (typeof obj === 'object') {\n            const objCopy = {};\n            copyKeys(objCopy, obj);\n            copyKeys(objCopy, copy[key]);\n            copy[key] = objCopy;\n        }\n    });\n    return copy;\n}\n\n// Parse a css attribute into the numeric portion and the units\nfunction parseAttribute(attribute, defaultValue) {\n    // 1em, 1.0em, 0.1em, .1em, 1.    em\n    const re = /^(-{0,1}\\.{0,1}\\d+(\\.\\d+)?)[\\s|\\.]*(\\w*)$/;\n    if (attribute && re.test(attribute)) {\n        const match = re.exec(attribute);\n        const number = match[1];\n        const units = match[3] || 'px';\n        return { value: number * 1, units, original: attribute };\n    }\n    if (defaultValue) {\n        return parseAttribute(defaultValue);\n    }\n    return { original: defaultValue };\n}\n\n// Set the html of a container. Should support both raw text and a single\n// DOM Element.\nfunction setHTML(container, content) {\n    if (container) {\n        // Clear out everything in the container\n        while (container.firstChild) {\n            container.removeChild(container.firstChild);\n        }\n        if (content) {\n            if (typeof content === 'string') {\n                container.innerHTML = content;\n            } else {\n                container.appendChild(content);\n            }\n        }\n    }\n}\n\n// Get the opposite of a given position\nfunction oppositePosition(p) {\n    if (p === 'top') {\n        return 'bottom';\n    } else if (p === 'bottom') {\n        return 'top';\n    } else if (p === 'left') {\n        return 'right';\n    } else if (p === 'right') {\n        return 'left';\n    }\n    return p;\n}\n\n// Return the position with the first letter capitalized\nfunction capitalizePosition(p) {\n    return p.charAt(0).toUpperCase() + p.slice(1);\n}\n\nexport default class SnazzyInfoWindow extends google.maps.OverlayView {\n\n    constructor(opts) {\n        super(opts);\n        // Private properties\n        this._html = null;\n        this._opts = mergeDefaultOptions(opts);\n        this._callbacks = this._opts.callbacks || {};\n        this._marker = this._opts.marker;\n        this._isOpen = false;\n        this._listeners = [];\n\n        // This listener remains active when the info window is closed.\n        if (google && this._marker && this._opts.openOnMarkerClick) {\n            this._openOnMarkerClickListener = google.maps.event.addListener(this._marker, 'click', () => {\n                if (!this.getMap()) {\n                    this.open();\n                }\n            });\n        }\n\n        // Validate the options\n        let p = this._opts.position;\n        if (p) {\n            p = p.toLowerCase();\n        }\n        if (p !== 'top' && p !== 'bottom' &&\n            p !== 'left' && p !== 'right') {\n            this._opts.position = _defaultOptions.position;\n        }\n        if (this._opts.border === undefined || this._opts.border === true) {\n            this._opts.border = {};\n        }\n        if (this._opts.pointer === undefined) {\n            this._opts.pointer = _defaultOptions.pointer;\n        }\n        if (this._opts.shadow === undefined || this._opts.shadow === true) {\n            this._opts.shadow = {};\n        }\n    }\n\n    // Activate the specified callback and return the result\n    activateCallback(callback) {\n        const lamda = this._callbacks[callback];\n        return lamda ? lamda.apply(this) : undefined;\n    }\n\n    // Will clear all listeners that are used during the open state.\n    clearListeners() {\n        if (google) {\n            if (this._listeners) {\n                this._listeners.forEach((listener) => {\n                    google.maps.event.removeListener(listener);\n                });\n            }\n            this._listeners = [];\n        }\n    }\n\n    // Open the info window after attaching to a specific marker.\n    open() {\n        const result = this.activateCallback('beforeOpen');\n        if (result !== undefined && !result) {\n            return;\n        }\n        if (this._marker) {\n            this.setMap(this._marker.getMap());\n        }\n    }\n\n    // Close the info window.\n    close() {\n        const result = this.activateCallback('beforeClose');\n        if (result !== undefined && !result) {\n            return;\n        }\n        this.clearListeners();\n        this.setMap(null);\n    }\n\n    // Force close the map and remove any event listeners attached to google\n    destroy() {\n        if (this.getMap()) {\n            this.setMap(null);\n        }\n\n        if (google) {\n            if (this._openOnMarkerClickListener) {\n                google.maps.event.removeListener(this._openOnMarkerClickListener);\n                this._openOnMarkerClickListener = null;\n            }\n        }\n        this.clearListeners();\n    }\n\n    setContent(content) {\n        this._opts.content = content;\n        if (this._html && this._html.content) {\n            setHTML(this._html.content, content);\n        }\n    }\n\n    // Implementation of OverlayView draw method.\n    draw() {\n        if (!this._marker || !this._html) {\n            return;\n        }\n\n        // 1. Assign offset\n        const offset = this._opts.offset;\n        if (offset) {\n            if (offset.left) {\n                this._html.wrapper.style.marginLeft = offset.left;\n            }\n            if (offset.top) {\n                this._html.wrapper.style.marginTop = offset.top;\n            }\n        }\n        // 2. Set the background color\n        const bg = this._opts.backgroundColor;\n        if (bg) {\n            this._html.contentWrapper.style.backgroundColor = bg;\n            if (this._opts.pointer) {\n                this._html.pointerBg.style[`border${capitalizePosition(this._opts.position)}Color`] = bg;\n            }\n        }\n        // 3. Padding\n        if (this._opts.padding) {\n            this._html.contentWrapper.style.padding = this._opts.padding;\n            if (this._opts.shadow) {\n                this._html.shadowFrame.style.padding = this._opts.padding;\n            }\n        }\n        // 4. Border radius\n        if (this._opts.borderRadius) {\n            this._html.contentWrapper.style.borderRadius = this._opts.borderRadius;\n            if (this._opts.shadow) {\n                this._html.shadowFrame.style.borderRadius = this._opts.borderRadius;\n            }\n        }\n        // 5. Font Size\n        if (this._opts.fontSize) {\n            this._html.wrapper.style.fontSize = this._opts.fontSize;\n        }\n        // 6. Font Color\n        if (this._opts.fontColor) {\n            this._html.contentWrapper.style.color = this._opts.fontColor;\n        }\n        // 7. Pointer\n        // Check if the pointer is enabled. Also make sure the value isn't just the boolean true.\n        if (this._opts.pointer && this._opts.pointer !== true) {\n            if (this._opts.shadow) {\n                this._html.shadowPointer.style.width = this._opts.pointer;\n                this._html.shadowPointer.style.height = this._opts.pointer;\n            }\n            if (this._html.pointerBorder) {\n                this._html.pointerBorder.style.borderWidth = this._opts.pointer;\n            }\n            this._html.pointerBg.style.borderWidth = this._opts.pointer;\n        }\n\n        // 8. Border\n        if (this._opts.border) {\n            // Calculate the border width\n            let bWidth = 0;\n            if (this._opts.border.width !== undefined) {\n                bWidth = parseAttribute(this._opts.border.width, '0px');\n                this._html.contentWrapper.style.borderWidth = bWidth.value + bWidth.units;\n            }\n            bWidth = Math.round((this._html.contentWrapper.offsetWidth -\n                     this._html.contentWrapper.clientWidth) / 2.0);\n            bWidth = parseAttribute(`${bWidth}px`, '0px');\n\n            if (this._opts.pointer) {\n                // Calculate the pointer length\n                let pLength = Math.min(this._html.pointerBorder.offsetHeight,\n                                       this._html.pointerBorder.offsetWidth);\n                pLength = parseAttribute(`${pLength}px`, '0px');\n\n                let triangleDiff = Math.round(bWidth.value * (_root2 - 1));\n                triangleDiff = Math.min(triangleDiff, pLength.value);\n\n                this._html.pointerBg.style.borderWidth =\n                    (pLength.value - triangleDiff) + pLength.units;\n\n                const reverseP = capitalizePosition(oppositePosition(this._opts.position));\n                this._html.pointerBg.style[`margin${reverseP}`] =\n                    triangleDiff + bWidth.units;\n                this._html.pointerBg.style[this._opts.position] =\n                    -bWidth.value + bWidth.units;\n            }\n            const color = this._opts.border.color;\n            if (color) {\n                this._html.contentWrapper.style.borderColor = color;\n                if (this._html.pointerBorder) {\n                    this._html.pointerBorder.style[`border${capitalizePosition(this._opts.position)}Color`] = color;\n                }\n            }\n        }\n        // 9. Shadow\n        if (this._opts.shadow) {\n            // Check if any of the shadow settings have actually been set\n            const shadow = this._opts.shadow;\n            const isSet = (attribute) => {\n                const v = shadow[attribute];\n                return v !== undefined && v != null;\n            };\n\n            if (isSet('h') || isSet('v') || isSet('blur') || isSet('spread') || isSet('color')) {\n                const hOffset = parseAttribute(shadow.h, _defaultShadow.h);\n                const vOffset = parseAttribute(shadow.v, _defaultShadow.v);\n                const blur = parseAttribute(shadow.blur, _defaultShadow.blur);\n                const spread = parseAttribute(shadow.spread, _defaultShadow.spread);\n                const color = shadow.color || _defaultShadow.color;\n                const formatBoxShadow = (h, v) => {\n                    return `${h} ${v} ${blur.original} ${spread.original} ${color}`;\n                };\n\n                this._html.shadowFrame.style.boxShadow =\n                    formatBoxShadow(hOffset.original, vOffset.original);\n\n                // Correctly rotate the shadows before the css transform\n                const hRotated = (_inverseRoot2 * (hOffset.value - vOffset.value)) + hOffset.units;\n                const vRotated = (_inverseRoot2 * (hOffset.value + vOffset.value)) + vOffset.units;\n                this._html.shadowPointerInner.style.boxShadow = formatBoxShadow(hRotated, vRotated);\n            }\n            if (this._opts.shadow.opacity) {\n                this._html.shadowWrapper.style.opacity = this._opts.shadow.opacity;\n            }\n        }\n\n        const markerPos = this.getProjection().fromLatLngToDivPixel(this._marker.position);\n        this._html.floatWrapper.style.top = `${Math.floor(markerPos.y)}px`;\n        this._html.floatWrapper.style.left = `${Math.floor(markerPos.x)}px`;\n\n        if (!this._isOpen) {\n            this._isOpen = true;\n            this.resize();\n            this.reposition();\n            this.activateCallback('afterOpen');\n        }\n    }\n\n    // Implementation of OverlayView onAdd method.\n    onAdd() {\n        if (this._html) {\n            return;\n        }\n        // Used for creating new elements\n        const applyCss = (element, args) => {\n            if (element && args) {\n                for (let i = 0; i < args.length; i++) {\n                    const className = args[i];\n                    if (className) {\n                        if (element.className) {\n                            element.className += ' ';\n                        }\n                        element.className += _classPrefix + className;\n                    }\n                }\n            }\n        };\n        const newElement = (...args) => {\n            const element = document.createElement('div');\n            applyCss(element, args);\n            return element;\n        };\n\n        this._html = {};\n\n        // 1. Create the wrapper\n        this._html.wrapper = newElement(\n            `wrapper-${this._opts.position}`\n        );\n        if (this._opts.wrapperClass) {\n            applyCss(this._html.wrapper, [`${this._opts.wrapperClass}`]);\n        }\n        if (this._opts.border) {\n            applyCss(this._html.wrapper, ['has-border']);\n        }\n\n        // 2. Create the shadow\n        if (this._opts.shadow) {\n            this._html.shadowWrapper = newElement(\n                `shadow-wrapper-${this._opts.position}`\n            );\n            this._html.shadowFrame = newElement(\n                'frame',\n                'shadow-frame'\n            );\n            this._html.shadowWrapper.appendChild(this._html.shadowFrame);\n\n            if (this._opts.pointer) {\n                this._html.shadowPointer = newElement(\n                    `shadow-pointer-${this._opts.position}`\n                );\n                this._html.shadowPointerInner = newElement(\n                    `shadow-inner-pointer-${this._opts.position}`\n                );\n                this._html.shadowPointer.appendChild(this._html.shadowPointerInner);\n                this._html.shadowWrapper.appendChild(this._html.shadowPointer);\n            }\n\n            this._html.wrapper.appendChild(this._html.shadowWrapper);\n        }\n\n        // 3. Create the content\n        this._html.contentWrapper = newElement(\n            'frame',\n            'content-wrapper'\n        );\n        this._html.content = newElement(\n            'content'\n        );\n        if (this._opts.content) {\n            setHTML(this._html.content, this._opts.content);\n        }\n\n        // 4. Create the close button\n        if (this._opts.showCloseButton) {\n            if (this._opts.closeButtonMarkup) {\n                const d = document.createElement('div');\n                setHTML(d, this._opts.closeButtonMarkup);\n                this._html.closeButton = d.firstChild;\n            } else {\n                this._html.closeButton = document.createElement('button');\n                this._html.closeButton.setAttribute('type', 'button');\n                this._html.closeButton.innerHTML = '&#215;';\n                applyCss(this._html.closeButton, ['close-button']);\n            }\n            this._html.contentWrapper.appendChild(this._html.closeButton);\n        }\n        this._html.contentWrapper.appendChild(this._html.content);\n        this._html.wrapper.appendChild(this._html.contentWrapper);\n\n        // 5. Create the pointer\n        if (this._opts.pointer) {\n            if (this._opts.border) {\n                this._html.pointerBorder = newElement(\n                    `pointer-${this._opts.position}`,\n                    `pointer-border-${this._opts.position}`\n                );\n                this._html.wrapper.appendChild(this._html.pointerBorder);\n            }\n            this._html.pointerBg = newElement(\n                `pointer-${this._opts.position}`,\n                `pointer-bg-${this._opts.position}`\n            );\n            this._html.wrapper.appendChild(this._html.pointerBg);\n        }\n\n        // Create an outer wrapper\n        this._html.floatWrapper = newElement(\n            'float-wrapper'\n        );\n        this._html.floatWrapper.appendChild(this._html.wrapper);\n\n        // Add the wrapper to the Google Maps float pane\n        this.getPanes().floatPane.appendChild(this._html.floatWrapper);\n\n        // Now add all the event listeners\n        const map = this.getMap();\n        this.clearListeners();\n        if (this._opts.closeOnMapClick) {\n            this._listeners.push(google.maps.event.addListener(map, 'click', () => {\n                this.close();\n            }));\n        }\n        if (google) {\n            // Clear out the previous map bounds\n            this._previousWidth = null;\n            this._previousHeight = null;\n            this._listeners.push(google.maps.event.addListener(map, 'bounds_changed', () => {\n                const d = map.getDiv();\n                const ow = d.offsetWidth;\n                const oh = d.offsetHeight;\n                const pw = this._previousWidth;\n                const ph = this._previousHeight;\n                if (pw === null || ph === null || pw !== ow || ph !== oh) {\n                    this._previousWidth = ow;\n                    this._previousHeight = oh;\n                    this.resize();\n                }\n            }));\n\n            // Marker moves\n            if (this._marker) {\n                this._listeners.push(google.maps.event.addListener(this._marker,\n                    'position_changed', () => {\n                        this.draw();\n                    }));\n            }\n\n            // Close button\n            if (this._opts.showCloseButton && !this._opts.closeButtonMarkup) {\n                this._listeners.push(google.maps.event.addDomListener(this._html.closeButton,\n                    'click', (e) => {\n                        e.cancelBubble = true;\n                        if (e.stopPropagation) {\n                            e.stopPropagation();\n                        }\n                        this.close();\n                    }));\n            }\n\n            // Stop the mouse event propagation\n            const mouseEvents = ['click', 'dblclick', 'rightclick', 'contextmenu',\n                'drag', 'dragend', 'dragstart',\n                'mousedown', 'mouseout', 'mouseover', 'mouseup',\n                'touchstart', 'touchend', 'touchmove',\n                'wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];\n            mouseEvents.forEach((event) => {\n                this._listeners.push(google.maps.event.addDomListener(this._html.wrapper,\n                    event, (e) => {\n                        e.cancelBubble = true;\n                        if (e.stopPropagation) {\n                            e.stopPropagation();\n                        }\n                    }));\n            });\n        }\n\n\n        this.activateCallback('open');\n    }\n\n    // Implementation of OverlayView onRemove method\n    onRemove() {\n        this.activateCallback('close');\n        if (this._html) {\n            const parent = this._html.floatWrapper.parentElement;\n            if (parent) {\n                parent.removeChild(this._html.floatWrapper);\n            }\n            this._html = null;\n        }\n        this._isOpen = false;\n        this.activateCallback('afterClose');\n    }\n\n    // The map inner bounds used for panning and resizing\n    getMapInnerBounds() {\n        const mb = this.getMap().getDiv().getBoundingClientRect();\n        const mib = {\n            top: mb.top + this._opts.edgeOffset.top,\n            right: mb.right - this._opts.edgeOffset.right,\n            bottom: mb.bottom - this._opts.edgeOffset.bottom,\n            left: mb.left + this._opts.edgeOffset.left\n        };\n        mib.width = mib.right - mib.left;\n        mib.height = mib.bottom - mib.top;\n        return mib;\n    }\n\n    // Pan the google map such that the info window is visible\n    reposition() {\n        if (!this._opts.panOnOpen || !this._html) {\n            return;\n        }\n        const mib = this.getMapInnerBounds();\n        const wb = this._html.wrapper.getBoundingClientRect();\n        let dx = 0;\n        let dy = 0;\n        if (mib.left >= wb.left) {\n            dx = wb.left - mib.left;\n        } else if (mib.right <= wb.right) {\n            dx = wb.left - (mib.right - wb.width);\n        }\n        if (mib.top >= wb.top) {\n            dy = wb.top - mib.top;\n        } else if (mib.bottom <= wb.bottom) {\n            dy = wb.top - (mib.bottom - wb.height);\n        }\n        if (dx !== 0 || dy !== 0) {\n            this.getMap().panBy(dx, dy);\n        }\n    }\n\n    // Resize the info window to fit within the map bounds and edge offset\n    resize() {\n        if (!this._html) {\n            return;\n        }\n        const mib = this.getMapInnerBounds();\n        // Handle the max width\n        let maxWidth = mib.width;\n        if (this._opts.maxWidth !== undefined) {\n            maxWidth = Math.min(maxWidth, this._opts.maxWidth);\n        }\n        maxWidth -= (this._html.wrapper.offsetWidth - this._html.content.offsetWidth);\n        this._html.content.style.maxWidth = `${maxWidth}px`;\n\n        // Handle the max height\n        let maxHeight = mib.height;\n        if (this._opts.maxHeight !== undefined) {\n            maxHeight = Math.min(maxHeight, this._opts.maxHeight);\n        }\n        maxHeight -= (this._html.wrapper.offsetHeight - this._html.content.offsetHeight);\n        this._html.content.style.maxHeight = `${maxHeight}px`;\n    }\n}\n"]}