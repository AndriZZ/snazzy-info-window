{"version":3,"sources":["snazzy-info-window.js"],"names":["copyKeys","target","source","Object","keys","forEach","key","mergeDefaultOptions","opts","copy","_defaultOptions","obj","_typeof","objCopy","parseAttribute","attribute","defaultValue","re","test","match","exec","number","units","value","original","_classPrefix","_root2","_inverseRoot2","_defaultShadow","h","v","blur","spread","color","position","pointer","openOnMarkerClick","closeOnMapClick","showCloseButton","panOnOpen","edgeOffset","top","right","bottom","left","SnazzyInfoWindow","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_html","_opts","_callbacks","callbacks","_marker","marker","_isOpen","_listeners","google","_openOnMarkerClickListener","maps","event","addListener","getMap","open","p","toLowerCase","undefined","border","shadow","callback","lamda","apply","listener","removeListener","result","activateCallback","setMap","clearListeners","content","innerHTML","_this2","charAt","toUpperCase","slice","capitalizedPosition","offset","wrapper","style","marginLeft","marginTop","bg","backgroundColor","pointerBg","padding","contentWrapper","shadowFrame","borderRadius","fontColor","fontSize","width","bWidth","borderWidth","Math","round","borderColor","pointerBorder","shadowPointer","height","isSet","hOffset","vOffset","formatBoxShadow","boxShadow","hRotated","vRotated","shadowPointerInner","opacity","shadowWrapper","markerPos","getProjection","fromLatLngToDivPixel","floatWrapper","floor","y","x","resize","reposition","_this3","applyCss","element","args","i","length","className","newElement","_len","arguments","Array","_key","document","createElement","wrapperClass","appendChild","closeButtonMarkup","d","closeButton","firstChild","setAttribute","getPanes","floatPane","map","push","close","_previousWidth","_previousHeight","getDiv","ow","offsetWidth","oh","offsetHeight","pw","ph","draw","addDomListener","e","cancelBubble","stopPropagation","mouseEvents","parent","parentElement","removeChild","mb","getBoundingClientRect","mib","getMapInnerBounds","wb","dx","dy","panBy","maxWidth","min","maxHeight","OverlayView"],"mappings":"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","file":"snazzy-info-window.min.js","sourcesContent":["// Global variables\nconst _classPrefix = 'si-';\nconst _root2 = 1.41421356237;\nconst _inverseRoot2 = 0.7071067811865474;\nconst _defaultShadow = {\n    h: '0px',\n    v: '3px',\n    blur: '6px',\n    spread: '0px',\n    color: '#000'\n};\nconst _defaultOptions = {\n    position: 'top',\n    pointer: true,\n    openOnMarkerClick: true,\n    closeOnMapClick: true,\n    showCloseButton: true,\n    panOnOpen: true,\n    edgeOffset: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 20\n    }\n};\n\n// Copy keys from the source into the target\nfunction copyKeys(target, source) {\n    if (target && source) {\n        Object.keys(source).forEach((key) => {\n            target[key] = source[key];\n        });\n    }\n}\n\n// We need to safely merge options from the defaults. This will make\n// sure settings like edgeOffset are properly assigned.\nfunction mergeDefaultOptions(opts) {\n    const copy = {};\n    copyKeys(copy, _defaultOptions);\n    copyKeys(copy, opts);\n    Object.keys(_defaultOptions).forEach((key) => {\n        const obj = _defaultOptions[key];\n        if (typeof obj === 'object') {\n            const objCopy = {};\n            copyKeys(objCopy, obj);\n            copyKeys(objCopy, copy[key]);\n            copy[key] = objCopy;\n        }\n    });\n    return copy;\n}\n\n// Parse a css attribute into the numeric portion and the units\nfunction parseAttribute(attribute, defaultValue) {\n    // 1em, 1.0em, 0.1em, .1em, 1.    em\n    const re = /^(-{0,1}\\.{0,1}\\d+(\\.\\d+)?)[\\s|\\.]*(\\w*)$/;\n    if (attribute && re.test(attribute)) {\n        const match = re.exec(attribute);\n        const number = match[1];\n        const units = match[3] || 'px';\n        return { value: number * 1, units, original: attribute };\n    }\n    if (defaultValue) {\n        return parseAttribute(defaultValue);\n    }\n    return { original: defaultValue };\n}\n\nexport default class SnazzyInfoWindow extends google.maps.OverlayView {\n\n    constructor(opts) {\n        super(opts);\n        // Private properties\n        this._html = null;\n        this._opts = mergeDefaultOptions(opts);\n        this._callbacks = this._opts.callbacks || {};\n        this._marker = this._opts.marker;\n        this._isOpen = false;\n        this._listeners = [];\n\n        // This listener remains active when the info window is closed.\n        if (google && this._marker && this._opts.openOnMarkerClick) {\n            this._openOnMarkerClickListener = google.maps.event.addListener(this._marker, 'click', () => {\n                if (!this.getMap()) {\n                    this.open();\n                }\n            });\n        }\n\n        // Validate the options\n        let p = this._opts.position;\n        if (p) {\n            p = p.toLowerCase();\n        }\n        if (p !== 'top' && p !== 'bottom' &&\n            p !== 'left' && p !== 'right') {\n            this._opts.position = _defaultOptions.position;\n        }\n        if (this._opts.border === undefined) {\n            this._opts.border = {};\n        }\n        if (this._opts.pointer === undefined) {\n            this._opts.pointer = _defaultOptions.pointer;\n        }\n        if (this._opts.shadow === undefined) {\n            this._opts.shadow = {};\n        }\n    }\n\n    // Activate the specified callback and return the result\n    activateCallback(callback) {\n        const lamda = this._callbacks[callback];\n        return lamda ? lamda.apply(this) : undefined;\n    }\n\n    // Will clear all listeners that are used during the open state.\n    clearListeners() {\n        if (google) {\n            if (this._listeners) {\n                this._listeners.forEach((listener) => {\n                    google.maps.event.removeListener(listener);\n                });\n            }\n            this._listeners = [];\n        }\n    }\n\n    // Open the info window after attaching to a specific marker.\n    open() {\n        const result = this.activateCallback('beforeOpen');\n        if (result !== undefined && !result) {\n            return;\n        }\n        if (this._marker) {\n            this.setMap(this._marker.getMap());\n        }\n    }\n\n    // Close the info window.\n    close() {\n        const result = this.activateCallback('beforeClose');\n        if (result !== undefined && !result) {\n            return;\n        }\n        this.clearListeners();\n        this.setMap(null);\n    }\n\n    // Force close the map and remove any event listeners attached to google\n    destroy() {\n        if (this.getMap()) {\n            this.setMap(null);\n        }\n\n        if (google) {\n            if (this._openOnMarkerClickListener) {\n                google.maps.event.removeListener(this._openOnMarkerClickListener);\n                this._openOnMarkerClickListener = null;\n            }\n        }\n        this.clearListeners();\n    }\n\n    setContent(content) {\n        this._opts.content = content;\n        if (this._html) {\n            this._html.content.innerHTML = content;\n        }\n    }\n\n    // Implementation of OverlayView draw method.\n    draw() {\n        if (!this._marker || !this._html) {\n            return;\n        }\n\n        // Returns a capitalized position for assigning styles\n        let p = this._opts.position;\n        p = p.charAt(0).toUpperCase() + p.slice(1);\n        const capitalizedPosition = p;\n\n        // 1. Assign offset\n        const offset = this._opts.offset;\n        if (offset) {\n            if (offset.left) {\n                this._html.wrapper.style.marginLeft = offset.left;\n            }\n            if (offset.top) {\n                this._html.wrapper.style.marginTop = offset.top;\n            }\n        }\n        // 2. Set the background color\n        const bg = this._opts.backgroundColor;\n        if (bg) {\n            this._html.content.style.backgroundColor = bg;\n            if (this._opts.pointer) {\n                this._html.pointerBg.style[`border${capitalizedPosition}Color`] = bg;\n            }\n        }\n        // 3. Padding\n        if (this._opts.padding) {\n            this._html.contentWrapper.style.padding = this._opts.padding;\n            this._html.shadowFrame.style.padding = this._opts.padding;\n        }\n        // 4. Border radius\n        if (this._opts.borderRadius) {\n            this._html.contentWrapper.style.borderRadius = this._opts.borderRadius;\n            this._html.shadowFrame.style.borderRadius = this._opts.borderRadius;\n        }\n        // 5. Font Color\n        if (this._opts.fontColor) {\n            this._html.wrapper.style.color = this._opts.fontColor;\n        }\n        // 6. Font Size\n        if (this._opts.fontSize) {\n            this._html.wrapper.style.fontSize = this._opts.fontSize;\n        }\n        // 7. Border\n        if (this._opts.border) {\n            if (this._opts.border.width !== undefined) {\n                const bWidth = parseAttribute(this._opts.border.width, '0px');\n                this._html.contentWrapper.style.borderWidth = bWidth.value + bWidth.units;\n                if (this._opts.pointer) {\n                    this._html.pointerBg.style[this._opts.position] =\n                        Math.round(-bWidth.value * _root2) + bWidth.units;\n                }\n            }\n            const color = this._opts.border.color;\n            if (color) {\n                this._html.contentWrapper.style.borderColor = color;\n                if (this._opts.pointer) {\n                    this._html.pointerBorder.style[`border${capitalizedPosition}Color`] = color;\n                }\n            }\n        } else {\n            // Hide the border when border is set to false\n            this._html.content.style.borderWidth = 0;\n            if (this._opts.pointer) {\n                this._html.pointerBg.style[this._opts.position] = 0;\n            }\n        }\n        // 8. Pointer\n        // Check if the pointer is enabled. Also make sure the value isn't just the boolean true.\n        if (this._opts.pointer && this._opts.pointer !== true) {\n            if (this._opts.shadow) {\n                this._html.shadowPointer.style.width = this._opts.pointer;\n                this._html.shadowPointer.style.height = this._opts.pointer;\n            }\n            this._html.pointerBorder.style.borderWidth = this._opts.pointer;\n            this._html.pointerBg.style.borderWidth = this._opts.pointer;\n        }\n\n        // 9. Shadow\n        if (this._opts.shadow) {\n            // Check if any of the shadow settings have actually been set\n            const shadow = this._opts.shadow;\n            const isSet = (attribute) => {\n                const v = shadow[attribute];\n                return v !== undefined && v != null;\n            };\n\n            if (isSet('h') || isSet('v') || isSet('blur') || isSet('spread') || isSet('color')) {\n                const hOffset = parseAttribute(shadow.h, _defaultShadow.h);\n                const vOffset = parseAttribute(shadow.v, _defaultShadow.v);\n                const blur = parseAttribute(shadow.blur, _defaultShadow.blur);\n                const spread = parseAttribute(shadow.spread, _defaultShadow.spread);\n                const color = shadow.color || _defaultShadow.color;\n                const formatBoxShadow = (h, v) => {\n                    return `${h} ${v} ${blur.original} ${spread.original} ${color}`;\n                };\n\n                this._html.shadowFrame.style.boxShadow =\n                    formatBoxShadow(hOffset.original, vOffset.original);\n\n                // Correctly rotate the shadows before the css transform\n                const hRotated = (_inverseRoot2 * (hOffset.value - vOffset.value)) + hOffset.units;\n                const vRotated = (_inverseRoot2 * (hOffset.value + vOffset.value)) + vOffset.units;\n                this._html.shadowPointerInner.style.boxShadow = formatBoxShadow(hRotated, vRotated);\n            }\n            if (this._opts.shadow.opacity) {\n                this._html.shadowWrapper.style.opacity = this._opts.shadow.opacity;\n            }\n        }\n\n        const markerPos = this.getProjection().fromLatLngToDivPixel(this._marker.position);\n        this._html.floatWrapper.style.top = `${Math.floor(markerPos.y)}px`;\n        this._html.floatWrapper.style.left = `${Math.floor(markerPos.x)}px`;\n\n        if (!this._isOpen) {\n            this._isOpen = true;\n            this.resize();\n            this.reposition();\n            this.activateCallback('afterOpen');\n        }\n    }\n\n    // Implementation of OverlayView onAdd method.\n    onAdd() {\n        if (this._html) {\n            return;\n        }\n        // Used for creating new elements\n        const applyCss = (element, args) => {\n            if (element && args) {\n                for (let i = 0; i < args.length; i++) {\n                    const className = args[i];\n                    if (className) {\n                        if (element.className) {\n                            element.className += ' ';\n                        }\n                        element.className += _classPrefix + className;\n                    }\n                }\n            }\n        };\n        const newElement = (...args) => {\n            const element = document.createElement('div');\n            applyCss(element, args);\n            return element;\n        };\n\n        this._html = {};\n\n        // 1. Create the wrapper\n        this._html.wrapper = newElement(\n            `wrapper-${this._opts.position}`\n        );\n        if (this._opts.wrapperClass) {\n            this._html.wrapper.className += ` ${this._opts.wrapperClass}`;\n        }\n\n        // 2. Create the shadow\n        if (this._opts.shadow) {\n            this._html.shadowWrapper = newElement(\n                `shadow-wrapper-${this._opts.position}`\n            );\n            this._html.shadowFrame = newElement(\n                'frame',\n                'shadow-frame'\n            );\n            this._html.shadowWrapper.appendChild(this._html.shadowFrame);\n\n            if (this._opts.pointer) {\n                this._html.shadowPointer = newElement(\n                    `shadow-pointer-${this._opts.position}`\n                );\n                this._html.shadowPointerInner = newElement(\n                    `shadow-inner-pointer-${this._opts.position}`\n                );\n                this._html.shadowPointer.appendChild(this._html.shadowPointerInner);\n                this._html.shadowWrapper.appendChild(this._html.shadowPointer);\n            }\n\n            this._html.wrapper.appendChild(this._html.shadowWrapper);\n        }\n\n        // 3. Create the content\n        this._html.contentWrapper = newElement(\n            'frame',\n            'content-wrapper'\n        );\n        this._html.content = newElement(\n            'content'\n        );\n        if (this._opts.content) {\n            this._html.content.innerHTML = this._opts.content;\n        }\n\n        // 4. Create the close button\n        if (this._opts.showCloseButton) {\n            if (this._opts.closeButtonMarkup) {\n                const d = document.createElement('div');\n                d.innerHTML = this._opts.closeButtonMarkup;\n                this._html.closeButton = d.firstChild;\n            } else {\n                this._html.closeButton = document.createElement('button');\n                this._html.closeButton.setAttribute('type', 'button');\n                this._html.closeButton.innerHTML = '&#215;';\n                applyCss(this._html.closeButton, ['close-button']);\n            }\n            this._html.contentWrapper.appendChild(this._html.closeButton);\n        }\n        this._html.contentWrapper.appendChild(this._html.content);\n        this._html.wrapper.appendChild(this._html.contentWrapper);\n\n        // 5. Create the pointer\n        if (this._opts.pointer) {\n            this._html.pointerBorder = newElement(\n                `pointer-${this._opts.position}`,\n                `pointer-border-${this._opts.position}`\n            );\n            this._html.pointerBg = newElement(\n                `pointer-${this._opts.position}`,\n                `pointer-bg-${this._opts.position}`\n            );\n            this._html.wrapper.appendChild(this._html.pointerBorder);\n            this._html.wrapper.appendChild(this._html.pointerBg);\n        }\n\n        // Create an outer wrapper\n        this._html.floatWrapper = newElement(\n            'float-wrapper'\n        );\n        this._html.floatWrapper.appendChild(this._html.wrapper);\n\n        // Add the wrapper to the Google Maps float pane\n        this.getPanes().floatPane.appendChild(this._html.floatWrapper);\n\n        // Now add all the event listeners\n        const map = this.getMap();\n        this.clearListeners();\n        if (this._opts.closeOnMapClick) {\n            this._listeners.push(google.maps.event.addListener(map, 'click', () => {\n                this.close();\n            }));\n        }\n        if (google) {\n            // Clear out the previous map bounds\n            this._previousWidth = null;\n            this._previousHeight = null;\n            this._listeners.push(google.maps.event.addListener(map, 'bounds_changed', () => {\n                const d = map.getDiv();\n                const ow = d.offsetWidth;\n                const oh = d.offsetHeight;\n                const pw = this._previousWidth;\n                const ph = this._previousHeight;\n                if (pw === null || ph === null || pw !== ow || ph !== oh) {\n                    this._previousWidth = ow;\n                    this._previousHeight = oh;\n                    this.resize();\n                }\n            }));\n\n            // Marker moves\n            if (this._marker) {\n                this._listeners.push(google.maps.event.addListener(this._marker,\n                    'position_changed', () => {\n                        this.draw();\n                    }));\n            }\n\n            // Close button\n            if (this._opts.showCloseButton && !this._opts.closeButtonMarkup) {\n                this._listeners.push(google.maps.event.addDomListener(this._html.closeButton,\n                    'click', (e) => {\n                        e.cancelBubble = true;\n                        if (e.stopPropagation) {\n                            e.stopPropagation();\n                        }\n                        this.close();\n                    }));\n            }\n\n            // Stop the mouse event propagation\n            const mouseEvents = ['click', 'dblclick', 'rightclick',\n                'drag', 'dragend', 'dragstart',\n                'mousedown', 'mouseout', 'mouseover', 'mouseup',\n                'touchstart', 'touchend', 'touchmove',\n                'wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];\n            mouseEvents.forEach((event) => {\n                this._listeners.push(google.maps.event.addDomListener(this._html.wrapper,\n                    event, (e) => {\n                        e.cancelBubble = true;\n                        if (e.stopPropagation) {\n                            e.stopPropagation();\n                        }\n                    }));\n            });\n        }\n\n\n        this.activateCallback('open');\n    }\n\n    // Implementation of OverlayView onRemove method\n    onRemove() {\n        this.activateCallback('close');\n        if (this._html) {\n            const parent = this._html.floatWrapper.parentElement;\n            if (parent) {\n                parent.removeChild(this._html.floatWrapper);\n            }\n            this._html = null;\n        }\n        this._isOpen = false;\n        this.activateCallback('afterClose');\n    }\n\n    // The map inner bounds used for panning and resizing\n    getMapInnerBounds() {\n        const mb = this.getMap().getDiv().getBoundingClientRect();\n        const mib = {\n            top: mb.top + this._opts.edgeOffset.top,\n            right: mb.right - this._opts.edgeOffset.right,\n            bottom: mb.bottom - this._opts.edgeOffset.bottom,\n            left: mb.left + this._opts.edgeOffset.left\n        };\n        mib.width = mib.right - mib.left;\n        mib.height = mib.bottom - mib.top;\n        return mib;\n    }\n\n    // Pan the google map such that the info window is visible\n    reposition() {\n        if (!this._opts.panOnOpen || !this._html) {\n            return;\n        }\n        const mib = this.getMapInnerBounds();\n        const wb = this._html.wrapper.getBoundingClientRect();\n        let dx = 0;\n        let dy = 0;\n        if (mib.left >= wb.left) {\n            dx = wb.left - mib.left;\n        } else if (mib.right <= wb.right) {\n            dx = wb.left - (mib.right - wb.width);\n        }\n        if (mib.top >= wb.top) {\n            dy = wb.top - mib.top;\n        } else if (mib.bottom <= wb.bottom) {\n            dy = wb.top - (mib.bottom - wb.height);\n        }\n        if (dx !== 0 || dy !== 0) {\n            this.getMap().panBy(dx, dy);\n        }\n    }\n\n    // Resize the info window to fit within the map bounds and edge offset\n    resize() {\n        if (!this._html) {\n            return;\n        }\n        const mib = this.getMapInnerBounds();\n        // Handle the max width\n        let maxWidth = mib.width;\n        if (this._opts.maxWidth !== undefined) {\n            maxWidth = Math.min(maxWidth, this._opts.maxWidth);\n        }\n        maxWidth -= (this._html.wrapper.offsetWidth - this._html.content.offsetWidth);\n        this._html.content.style.maxWidth = `${maxWidth}px`;\n\n        // Handle the max height\n        let maxHeight = mib.height;\n        if (this._opts.maxHeight !== undefined) {\n            maxHeight = Math.min(maxHeight, this._opts.maxHeight);\n        }\n        maxHeight -= (this._html.wrapper.offsetHeight - this._html.content.offsetHeight);\n        this._html.content.style.maxHeight = `${maxHeight}px`;\n    }\n}\n"]}