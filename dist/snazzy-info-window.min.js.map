{"version":3,"sources":["snazzy-info-window.js"],"names":["parseAttribute","attribute","defaultValue","re","test","match","exec","number","units","value","original","_classPrefix","_root2","_inverseRoot2","_defaultShadow","h","v","blur","spread","color","SnazzyInfoWindow","opts","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","call","_marker","_floatWrapper","_opts","p","position","toLowerCase","undefined","border","pointer","shadow","className","lambda","elements","getElementsByClassName","i","length","apply","marker","_this2","google","maps","event","addListener","open","setMap","getMap","_this3","charAt","toUpperCase","slice","capitalizedPosition","offset","left","eachByClassName","e","style","marginLeft","top","marginTop","bg","backgroundColor","padding","borderRadius","fontColor","fontSize","width","bWidth","borderWidth","Math","round","borderColor","height","isSet","hOffset","vOffset","formatBoxShadow","boxShadow","hRotated","vRotated","opacity","markerPos","getProjection","fromLatLngToDivPixel","floor","y","x","newElement","_len","arguments","args","Array","_key","element","document","createElement","wrapper","wrapperClass","shadowWrapper","shadowFrame","appendChild","shadowPointer","shadowPointerInner","contentWrapper","content","innerHTML","pointerBorder","pointerBg","floatWrapper","getPanes","floatPane","parent","parentElement","removeChild","OverlayView"],"mappings":"k0BAaA,QAASA,GAAeC,EAAWC,GAE/B,GAAMC,GAAK,2CACX,IAAIF,GAAaE,EAAGC,KAAKH,GAAY,CACjC,GAAMI,GAAQF,EAAGG,KAAKL,GAChBM,EAASF,EAAM,GACfG,EAAQH,EAAM,IAAM,IAC1B,QAASI,MAAgB,EAATF,EAAYC,MAAAA,EAAOE,SAAUT,GAEjD,MAAIC,GACOF,EAAeE,IAEjBQ,SAAUR,6SAxBjBS,EAAe,MACfC,EAAS,cACTC,EAAgB,kBAChBC,GACFC,EAAG,MACHC,EAAG,MACHC,KAAM,MACNC,OAAQ,MACRC,MAAO,QAmBUC,cAEjB,QAAAA,GAAYC,GAAMC,EAAAC,KAAAH,EAAA,IAAAI,GAAAC,EAAAF,MAAAH,EAAAM,WAAAC,OAAAC,eAAAR,IAAAS,KAAAN,KACRF,GAENG,GAAKM,QAAU,KACfN,EAAKO,cAAgB,KACrBP,EAAKQ,MAAQX,KAGb,IAAIY,GAAIT,EAAKQ,MAAME,QARL,OASVD,KACAA,EAAIA,EAAEE,eAEA,QAANF,GAAqB,WAANA,GACT,SAANA,GAAsB,UAANA,IAChBT,EAAKQ,MAAME,SAAW,OAEAE,SAAtBZ,EAAKQ,MAAMK,SACXb,EAAKQ,MAAMK,WAEYD,SAAvBZ,EAAKQ,MAAMM,UACXd,EAAKQ,MAAMM,SAAU,GAECF,SAAtBZ,EAAKQ,MAAMO,SACXf,EAAKQ,MAAMO,WAvBDf,2DA4BFgB,EAAWC,GACvB,GAAIlB,KAAKQ,cAEL,IAAK,GADCW,GAAWnB,KAAKQ,cAAcY,uBAAuBhC,EAAe6B,GACjEI,EAAI,EAAGA,EAAIF,EAASG,OAAQD,IAC7BH,GACAA,EAAOK,MAAMvB,MAAOmB,EAASE,oCAOtCG,GAAQ,GAAAC,GAAAzB,IACP0B,SAAqBb,SAAXW,IACVxB,KAAKO,QAAUiB,EACfE,OAAOC,KAAKC,MAAMC,YAAY7B,KAAKO,QAAS,QAAS,WACjDkB,EAAKK,yCAOT9B,KAAKO,SACLP,KAAK+B,OAAO/B,KAAKO,QAAQyB,0CAM7BhC,KAAK+B,OAAO,qCAIT,GAAAE,GAAAjC,IACH,IAAKA,KAAKO,SAAYP,KAAKQ,cAA3B,CAKA,GAAIE,GAAIV,KAAKS,MAAME,QACnBD,GAAIA,EAAEwB,OAAO,GAAGC,cAAgBzB,EAAE0B,MAAM,EACxC,IAAMC,GAAsB3B,EAGtB4B,EAAStC,KAAKS,MAAM6B,MACtBA,KACIA,EAAOC,MACPvC,KAAKwC,gBAAL,WAAgCxC,KAAKS,MAAME,SAAY,SAAC8B,GACpDA,EAAEC,MAAMC,WAAaL,EAAOC,OAGhCD,EAAOM,KACP5C,KAAKwC,gBAAL,WAAgCxC,KAAKS,MAAME,SAAY,SAAC8B,GACpDA,EAAEC,MAAMG,UAAYP,EAAOM,MAKvC,IAAME,GAAK9C,KAAKS,MAAMsC,eAClBD,KACA9C,KAAKwC,gBAAgB,UAAW,SAACC,GAC7BA,EAAEC,MAAMK,gBAAkBD,IAE1B9C,KAAKS,MAAMM,SACXf,KAAKwC,gBAAL,cAAmCxC,KAAKS,MAAME,SAAY,SAAC8B,GACvDA,EAAEC,MAAF,SAAiBL,EAAjB,SAA+CS,KAKvD9C,KAAKS,MAAMuC,SACXhD,KAAKwC,gBAAgB,QAAS,SAACC,GAC3BA,EAAEC,MAAMM,QAAUf,EAAKxB,MAAMuC,UAIjChD,KAAKS,MAAMwC,cACXjD,KAAKwC,gBAAgB,QAAS,SAACC,GAC3BA,EAAEC,MAAMO,aAAehB,EAAKxB,MAAMwC,eAItCjD,KAAKS,MAAMyC,WACXlD,KAAKwC,gBAAL,WAAgCxC,KAAKS,MAAME,SAAY,SAAC8B,GACpDA,EAAEC,MAAM9C,MAAQqC,EAAKxB,MAAMyC,YAI/BlD,KAAKS,MAAM0C,UACXnD,KAAKwC,gBAAL,WAAgCxC,KAAKS,MAAME,SAAY,SAAC8B,GACpDA,EAAEC,MAAMS,SAAWlB,EAAKxB,MAAM0C,WAIlCnD,KAAKS,MAAMK,QAAQ,WACaD,SAA5BoB,EAAKxB,MAAMK,OAAOsC,QAAqB,WACvC,GAAMC,GAAS5E,EAAewD,EAAKxB,MAAMK,OAAOsC,MAAO,MACvDnB,GAAKO,gBAAgB,UAAW,SAACC,GAC7BA,EAAEC,MAAMY,YAAcD,EAAOnE,MAAQmE,EAAOpE,QAE5CgD,EAAKxB,MAAMM,SACXkB,EAAKO,gBAAL,cAAmCP,EAAKxB,MAAME,SAAY,SAAC8B,GACvDA,EAAEC,MAAMT,EAAKxB,MAAME,UACf4C,KAAKC,OAAOH,EAAOnE,MAAQG,GAAUgE,EAAOpE,UAI5D,IAAMW,GAAQqC,EAAKxB,MAAMK,OAAOlB,KAC5BA,KACAqC,EAAKO,gBAAgB,UAAW,SAACC,GAC7BA,EAAEC,MAAMe,YAAc7D,IAEtBqC,EAAKxB,MAAMM,SACXkB,EAAKO,gBAAL,kBAAuCP,EAAKxB,MAAME,SAAY,SAAC8B,GAC3DA,EAAEC,MAAF,SAAiBL,EAAjB,SAA+CzC,SAM3DI,KAAKwC,gBAAgB,UAAW,SAACC,GAC7BA,EAAEC,MAAMY,YAAc,IAEtBtD,KAAKS,MAAMM,SACXf,KAAKwC,gBAAL,cAAmCxC,KAAKS,MAAME,SAAY,SAAC8B,GACvDA,EAAEC,MAAMT,EAAKxB,MAAME,UAAY,KAMvCX,KAAKS,MAAMM,SAAWf,KAAKS,MAAMM,WAAY,IACzCf,KAAKS,MAAMO,QACXhB,KAAKwC,gBAAL,kBAAuCxC,KAAKS,MAAME,SAAY,SAAC8B,GAC3DA,EAAEC,MAAMU,MAAQnB,EAAKxB,MAAMM,QAC3B0B,EAAEC,MAAMgB,OAASzB,EAAKxB,MAAMM,UAGpCf,KAAKwC,gBAAL,WAAgCxC,KAAKS,MAAME,SAAY,SAAC8B,GACpDA,EAAEC,MAAMY,YAAcrB,EAAKxB,MAAMM,WAKrCf,KAAKS,MAAMO,SAAQ,WAEnB,GAAMA,GAASiB,EAAKxB,MAAMO,OACpB2C,EAAQ,SAACjF,GACX,GAAMe,GAAIuB,EAAOtC,EACjB,OAAamC,UAANpB,GAAwB,MAALA,IAG1BkE,EAAM,MAAQA,EAAM,MAAQA,EAAM,SAAWA,EAAM,WAAaA,EAAM,YAAU,WAChF,GAAMC,GAAUnF,EAAeuC,EAAOxB,EAAGD,EAAeC,GAClDqE,EAAUpF,EAAeuC,EAAOvB,EAAGF,EAAeE,GAClDC,EAAOjB,EAAeuC,EAAOtB,KAAMH,EAAeG,MAClDC,EAASlB,EAAeuC,EAAOrB,OAAQJ,EAAeI,QACtDC,EAAQoB,EAAOpB,OAASL,EAAeK,MACvCkE,EAAkB,SAACtE,EAAGC,GACxB,MAAUD,GAAV,IAAeC,EAAf,IAAoBC,EAAKP,SAAzB,IAAqCQ,EAAOR,SAA5C,IAAwDS,EAG5DqC,GAAKO,gBAAgB,eAAgB,SAACC,GAClCA,EAAEC,MAAMqB,UAAYD,EAAgBF,EAAQzE,SAAU0E,EAAQ1E,WAGlE,IAAM6E,GAAY1E,GAAiBsE,EAAQ1E,MAAQ2E,EAAQ3E,OAAU0E,EAAQ3E,MACvEgF,EAAY3E,GAAiBsE,EAAQ1E,MAAQ2E,EAAQ3E,OAAU2E,EAAQ5E,KAC7EgD,GAAKO,gBAAL,wBAA6CP,EAAKxB,MAAME,SAAY,SAAC8B,GACjEA,EAAEC,MAAMqB,UAAYD,EAAgBE,EAAUC,QAGlDhC,EAAKxB,MAAMO,OAAOkD,SAClBjC,EAAKO,gBAAL,kBAAuCP,EAAKxB,MAAME,SAAY,SAAC8B,GAC3DA,EAAEC,MAAMwB,QAAUjC,EAAKxB,MAAMO,OAAOkD,YAKhD,IAAMC,GAAYnE,KAAKoE,gBAAgBC,qBAAqBrE,KAAKO,QAAQI,SACzEX,MAAKQ,cAAckC,MAAME,IAASW,KAAKe,MAAMH,EAAUI,GAAvD,KACAvE,KAAKQ,cAAckC,MAAMH,KAAUgB,KAAKe,MAAMH,EAAUK,GAAxD,sCAKA,IAAIxE,KAAKQ,cAAT,CAIA,GAAMiE,GAAa,WAAa,IAAA,GAAAC,GAAAC,UAAArD,OAATsD,EAASC,MAAAH,GAAAI,EAAA,EAAAA,EAAAJ,EAAAI,IAATF,EAASE,GAAAH,UAAAG,EAC5B,IAAMC,GAAUC,SAASC,cAAc,MACvC,IAAIL,EACA,IAAK,GAAIvD,GAAI,EAAGA,EAAIuD,EAAKtD,OAAQD,IAAK,CAClC,GAAMJ,GAAY2D,EAAKvD,EACnBJ,KACI8D,EAAQ9D,YACR8D,EAAQ9D,WAAa,KAEzB8D,EAAQ9D,WAAa7B,EAAe6B,GAIhD,MAAO8D,IAILG,EAAUT,EAAAA,WACDzE,KAAKS,MAAME,SAO1B,IALIX,KAAKS,MAAM0E,eACXD,EAAQjE,WAAR,IAAyBjB,KAAKS,MAAM0E,cAIpCnF,KAAKS,MAAMO,OAAQ,CACnB,GAAMoE,GAAgBX,EAAAA,kBACAzE,KAAKS,MAAME,UAE3B0E,EAAcZ,EAChB,QACA,eAIJ,IAFAW,EAAcE,YAAYD,GAEtBrF,KAAKS,MAAMM,QAAS,CACpB,GAAMwE,GAAgBd,EAAAA,kBACAzE,KAAKS,MAAME,UAE3B6E,EAAqBf,EAAAA,wBACCzE,KAAKS,MAAME,SAEvC4E,GAAcD,YAAYE,GAC1BJ,EAAcE,YAAYC,GAG9BL,EAAQI,YAAYF,GAIxB,GAAMK,GAAiBhB,EACnB,QACA,mBAEEiB,EAAUjB,EACZ,UASJ,IAPIzE,KAAKS,MAAMiF,UACXA,EAAQC,UAAY3F,KAAKS,MAAMiF,SAEnCD,EAAeH,YAAYI,GAC3BR,EAAQI,YAAYG,GAGhBzF,KAAKS,MAAMM,QAAS,CACpB,GAAM6E,GAAgBnB,EAAAA,WACPzE,KAAKS,MAAME,SADJ,kBAEAX,KAAKS,MAAME,UAE3BkF,EAAYpB,EAAAA,WACHzE,KAAKS,MAAME,SADR,cAEAX,KAAKS,MAAME,SAE7BuE,GAAQI,YAAYM,GACpBV,EAAQI,YAAYO,GAIxB,GAAMC,GAAerB,EACjB,gBAEJqB,GAAaR,YAAYJ,GACzBlF,KAAKQ,cAAgBsF,EAGrB9F,KAAK+F,WAAWC,UAAUV,YAAYtF,KAAKQ,mDAK3C,GAAIR,KAAKQ,cAAe,CACpB,GAAMyF,GAASjG,KAAKQ,cAAc0F,aAC9BD,IACAA,EAAOE,YAAYnG,KAAKQ,eAE5BR,KAAKQ,cAAgB,aA5TakB,OAAOC,KAAKyE,uBAArCvG","file":"snazzy-info-window.min.js","sourcesContent":["// Global variables\nconst _classPrefix = 'si-';\nconst _root2 = 1.41421356237;\nconst _inverseRoot2 = 0.7071067811865474;\nconst _defaultShadow = {\n    h: '0px',\n    v: '3px',\n    blur: '6px',\n    spread: '0px',\n    color: '#000'\n};\n\n// Parse a css attribute into the numeric portion and the units\nfunction parseAttribute(attribute, defaultValue) {\n    // 1em, 1.0em, 0.1em, .1em, 1.    em\n    const re = /^(-{0,1}\\.{0,1}\\d+(\\.\\d+)?)[\\s|\\.]*(\\w*)$/;\n    if (attribute && re.test(attribute)) {\n        const match = re.exec(attribute);\n        const number = match[1];\n        const units = match[3] || 'px';\n        return { value: number * 1, units, original: attribute };\n    }\n    if (defaultValue) {\n        return parseAttribute(defaultValue);\n    }\n    return { original: defaultValue };\n}\n\nexport default class SnazzyInfoWindow extends google.maps.OverlayView {\n\n    constructor(opts) {\n        super(opts);\n        // Private properties\n        this._marker = null;\n        this._floatWrapper = null;\n        this._opts = opts || {};\n\n        // Validate the options\n        let p = this._opts.position;\n        if (p) {\n            p = p.toLowerCase();\n        }\n        if (p !== 'top' && p !== 'bottom' &&\n            p !== 'left' && p !== 'right') {\n            this._opts.position = 'top';\n        }\n        if (this._opts.border === undefined) {\n            this._opts.border = {};\n        }\n        if (this._opts.pointer === undefined) {\n            this._opts.pointer = true;\n        }\n        if (this._opts.shadow === undefined) {\n            this._opts.shadow = {};\n        }\n    }\n\n    // Go through each element under the wrapper with the provided class name\n    eachByClassName(className, lambda) {\n        if (this._floatWrapper) {\n            const elements = this._floatWrapper.getElementsByClassName(_classPrefix + className);\n            for (let i = 0; i < elements.length; i++) {\n                if (lambda) {\n                    lambda.apply(this, [elements[i]]);\n                }\n            }\n        }\n    }\n\n    // Attach the info window to the specific marker.\n    attach(marker) {\n        if (google && marker !== undefined) {\n            this._marker = marker;\n            google.maps.event.addListener(this._marker, 'click', () => {\n                this.open();\n            });\n        }\n    }\n\n    // Open the info window after attaching to a specific marker.\n    open() {\n        if (this._marker) {\n            this.setMap(this._marker.getMap());\n        }\n    }\n\n    // Close the info window.\n    close() {\n        this.setMap(null);\n    }\n\n    // Implementation of OverlayView draw method.\n    draw() {\n        if (!this._marker || !this._floatWrapper) {\n            return;\n        }\n\n        // Returns a capitalized position for assigning styles\n        let p = this._opts.position;\n        p = p.charAt(0).toUpperCase() + p.slice(1);\n        const capitalizedPosition = p;\n\n        // 1. Assign offset\n        const offset = this._opts.offset;\n        if (offset) {\n            if (offset.left) {\n                this.eachByClassName(`wrapper-${this._opts.position}`, (e) => {\n                    e.style.marginLeft = offset.left;\n                });\n            }\n            if (offset.top) {\n                this.eachByClassName(`wrapper-${this._opts.position}`, (e) => {\n                    e.style.marginTop = offset.top;\n                });\n            }\n        }\n        // 2. Set the background color\n        const bg = this._opts.backgroundColor;\n        if (bg) {\n            this.eachByClassName('content', (e) => {\n                e.style.backgroundColor = bg;\n            });\n            if (this._opts.pointer) {\n                this.eachByClassName(`pointer-bg-${this._opts.position}`, (e) => {\n                    e.style[`border${capitalizedPosition}Color`] = bg;\n                });\n            }\n        }\n        // 3. Padding\n        if (this._opts.padding) {\n            this.eachByClassName('frame', (e) => {\n                e.style.padding = this._opts.padding;\n            });\n        }\n        // 4. Border radius\n        if (this._opts.borderRadius) {\n            this.eachByClassName('frame', (e) => {\n                e.style.borderRadius = this._opts.borderRadius;\n            });\n        }\n        // 5. Font Color\n        if (this._opts.fontColor) {\n            this.eachByClassName(`wrapper-${this._opts.position}`, (e) => {\n                e.style.color = this._opts.fontColor;\n            });\n        }\n        // 6. Font Size\n        if (this._opts.fontSize) {\n            this.eachByClassName(`wrapper-${this._opts.position}`, (e) => {\n                e.style.fontSize = this._opts.fontSize;\n            });\n        }\n        // 7. Border\n        if (this._opts.border) {\n            if (this._opts.border.width !== undefined) {\n                const bWidth = parseAttribute(this._opts.border.width, '0px');\n                this.eachByClassName('content', (e) => {\n                    e.style.borderWidth = bWidth.value + bWidth.units;\n                });\n                if (this._opts.pointer) {\n                    this.eachByClassName(`pointer-bg-${this._opts.position}`, (e) => {\n                        e.style[this._opts.position] =\n                            Math.round(-bWidth.value * _root2) + bWidth.units;\n                    });\n                }\n            }\n            const color = this._opts.border.color;\n            if (color) {\n                this.eachByClassName('content', (e) => {\n                    e.style.borderColor = color;\n                });\n                if (this._opts.pointer) {\n                    this.eachByClassName(`pointer-border-${this._opts.position}`, (e) => {\n                        e.style[`border${capitalizedPosition}Color`] = color;\n                    });\n                }\n            }\n        } else {\n            // Hide the border when border is set to false\n            this.eachByClassName('content', (e) => {\n                e.style.borderWidth = 0;\n            });\n            if (this._opts.pointer) {\n                this.eachByClassName(`pointer-bg-${this._opts.position}`, (e) => {\n                    e.style[this._opts.position] = 0;\n                });\n            }\n        }\n        // 8. Pointer\n        // Check if the pointer is enabled. Also make sure the value isn't just the boolean true.\n        if (this._opts.pointer && this._opts.pointer !== true) {\n            if (this._opts.shadow) {\n                this.eachByClassName(`shadow-pointer-${this._opts.position}`, (e) => {\n                    e.style.width = this._opts.pointer;\n                    e.style.height = this._opts.pointer;\n                });\n            }\n            this.eachByClassName(`pointer-${this._opts.position}`, (e) => {\n                e.style.borderWidth = this._opts.pointer;\n            });\n        }\n\n        // 9. Shadow\n        if (this._opts.shadow) {\n            // Check if any of the shadow settings have actually been set\n            const shadow = this._opts.shadow;\n            const isSet = (attribute) => {\n                const v = shadow[attribute];\n                return v !== undefined && v != null;\n            };\n\n            if (isSet('h') || isSet('v') || isSet('blur') || isSet('spread') || isSet('color')) {\n                const hOffset = parseAttribute(shadow.h, _defaultShadow.h);\n                const vOffset = parseAttribute(shadow.v, _defaultShadow.v);\n                const blur = parseAttribute(shadow.blur, _defaultShadow.blur);\n                const spread = parseAttribute(shadow.spread, _defaultShadow.spread);\n                const color = shadow.color || _defaultShadow.color;\n                const formatBoxShadow = (h, v) => {\n                    return `${h} ${v} ${blur.original} ${spread.original} ${color}`;\n                };\n\n                this.eachByClassName('shadow-frame', (e) => {\n                    e.style.boxShadow = formatBoxShadow(hOffset.original, vOffset.original);\n                });\n                // Correctly rotate the shadows before the css transform\n                const hRotated = (_inverseRoot2 * (hOffset.value - vOffset.value)) + hOffset.units;\n                const vRotated = (_inverseRoot2 * (hOffset.value + vOffset.value)) + vOffset.units;\n                this.eachByClassName(`shadow-inner-pointer-${this._opts.position}`, (e) => {\n                    e.style.boxShadow = formatBoxShadow(hRotated, vRotated);\n                });\n            }\n            if (this._opts.shadow.opacity) {\n                this.eachByClassName(`shadow-wrapper-${this._opts.position}`, (e) => {\n                    e.style.opacity = this._opts.shadow.opacity;\n                });\n            }\n        }\n\n        const markerPos = this.getProjection().fromLatLngToDivPixel(this._marker.position);\n        this._floatWrapper.style.top = `${Math.floor(markerPos.y)}px`;\n        this._floatWrapper.style.left = `${Math.floor(markerPos.x)}px`;\n    }\n\n    // Implementation of OverlayView onAdd method.\n    onAdd() {\n        if (this._floatWrapper) {\n            return;\n        }\n        // Used for creating new elements\n        const newElement = (...args) => {\n            const element = document.createElement('div');\n            if (args) {\n                for (let i = 0; i < args.length; i++) {\n                    const className = args[i];\n                    if (className) {\n                        if (element.className) {\n                            element.className += ' ';\n                        }\n                        element.className += _classPrefix + className;\n                    }\n                }\n            }\n            return element;\n        };\n\n        // 1. Create the wrapper\n        const wrapper = newElement(\n            `wrapper-${this._opts.position}`\n        );\n        if (this._opts.wrapperClass) {\n            wrapper.className += ` ${this._opts.wrapperClass}`;\n        }\n\n        // 2. Create the shadow\n        if (this._opts.shadow) {\n            const shadowWrapper = newElement(\n                `shadow-wrapper-${this._opts.position}`\n            );\n            const shadowFrame = newElement(\n                'frame',\n                'shadow-frame'\n            );\n            shadowWrapper.appendChild(shadowFrame);\n\n            if (this._opts.pointer) {\n                const shadowPointer = newElement(\n                    `shadow-pointer-${this._opts.position}`\n                );\n                const shadowPointerInner = newElement(\n                    `shadow-inner-pointer-${this._opts.position}`\n                );\n                shadowPointer.appendChild(shadowPointerInner);\n                shadowWrapper.appendChild(shadowPointer);\n            }\n\n            wrapper.appendChild(shadowWrapper);\n        }\n\n        // 3. Create the content\n        const contentWrapper = newElement(\n            'frame',\n            'content-wrapper'\n        );\n        const content = newElement(\n            'content'\n        );\n        if (this._opts.content) {\n            content.innerHTML = this._opts.content;\n        }\n        contentWrapper.appendChild(content);\n        wrapper.appendChild(contentWrapper);\n\n        // 4. Create the pointer\n        if (this._opts.pointer) {\n            const pointerBorder = newElement(\n                `pointer-${this._opts.position}`,\n                `pointer-border-${this._opts.position}`\n            );\n            const pointerBg = newElement(\n                `pointer-${this._opts.position}`,\n                `pointer-bg-${this._opts.position}`\n            );\n            wrapper.appendChild(pointerBorder);\n            wrapper.appendChild(pointerBg);\n        }\n\n        // Create an outer wrapper\n        const floatWrapper = newElement(\n            'float-wrapper'\n        );\n        floatWrapper.appendChild(wrapper);\n        this._floatWrapper = floatWrapper;\n\n        // Add the wrapper to the Google Maps float pane\n        this.getPanes().floatPane.appendChild(this._floatWrapper);\n    }\n\n    // Implementation of OverlayView onRemove method\n    onRemove() {\n        if (this._floatWrapper) {\n            const parent = this._floatWrapper.parentElement;\n            if (parent) {\n                parent.removeChild(this._floatWrapper);\n            }\n            this._floatWrapper = null;\n        }\n    }\n}\n"]}